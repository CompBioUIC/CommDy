#!/usr/bin/python

import sys,re

from GtmFile import *
from GlpxOutput import *
from GroupGraph import *
import sys,re,os

gtm_fname = None
pc_fname = None
limit=None
quiet=False
verbose=False

for arg in sys.argv[1:]:
	p = re.compile('-.+')
	if p.match(arg):
		if arg == '-1':
			limit=1
		elif arg == '-v':
			verbose=True
		elif arg == '-q':
			quiet=True
		else:
			print "Unknown option", arg
			exit(1)
	else:
		if arg.endswith('.gtm') or arg.endswith('.gtm2'):
			gtm_fname = arg
		elif arg.endswith('.out'):
			pc_fname = arg
		else:
			print 'Unknown file extension:', arg
			exit(1)

if gtm_fname is None:
	gtm_fname = guess_gtmfile()
gtm = GtmFile(gtm_fname)

for g,s in gtm.group.iteritems():
	gtm.group[g] = set(s)

group_graph = GroupGraph(gtm)
group = group_graph.group
group_time = group_graph.group_time

if gtm_fname[-4:] != ".gtm" and gtm_fname[-5:] != ".gtm2":
	raise
bname = os.path.splitext(os.path.basename(gtm_fname))[0]
pid=os.getpid()
prefix = os.path.dirname(gtm_fname)
if prefix!="": prefix += os.path.sep
out_fname = prefix + "%s-ipc.glpk.%d.out" %(bname,pid)
gms_fname = prefix + "%s-ipc.glpk.%d.mod" %(bname,pid)
log_fname = prefix + "%s-ipc.glpk.%d.log" %(bname,pid)
#out_fname = "%s-ipc.glpk.out" %(bname)
#gms_fname = "%s-ipc.glpk.mod" %(bname)
#log_fname = "%s-ipc.glpk.log" %(bname)

pc_edges=[]
if pc_fname is not None:
	# read pathcover file
	f = open(pc_fname, 'r')
	for line in f.readlines():
		line = line.strip()
		line = map(int, line.split(','))
		if len(line)==3:
			u,v,w = line
		elif len(line)==2:
			u,v = line
		else: raise
		pc_edges.append((u,v))

it_count=0
while limit is None or it_count<limit:
	it_count+=1
	sys.stderr.write("iteration %d: "%it_count)

	#sys.stderr.write("assign parents\n")

	# assign parent
	parent = {}
	for e in pc_edges:
		u,v = e
		if group_graph.group_time[u]>group_graph.group_time[v]:
			print "u", u, group_graph.group_time[u], 
			print "v", v, group_graph.group_time[v]
			raise Exception("Found an edge going back in time")
		if v in parent: 
			print "u", u, "t", group_graph.group_time[u]
			print "v", v, "t", group_graph.group_time[v]
			print "parent[v]", parent[v], "t", group_graph.group_time[parent[v]]
			raise Exception("Input is not a path cover. "
					+"Vertex %s has two parents: %s and %s."%(v, parent[v], u))
		parent[v] = u

	## debug print
	#for g in range(1, len(group_graph.groups)+1):
	#	print "group", g, "time", group_time[g], "members:",
	#	for i in sorted(group[g]):
	#		print i,
	#	print

	#outedge = {}
	#inedge = {}
	#for index,e in enumerate(edges):
	#	(g,h) = e
	#	if g not in outedge: outedge[g]=[]
	#	outedge[g].append((g,h))
	#	if h not in inedge: inedge[h]=[]
	#	inedge[h].append((g,h))

	# prepare to create path graph
	paths = []
	first_group = {}
	last_group = {}

	#sys.stderr.write("find paths\n")

	for g in group_graph.groups_intime:
		if g in parent and parent[g] != g: # possibly ending node of a path
			h = parent[g]
			if h in first_group:
				p = first_group[h]
			else:
				p = h
			first_group[g] = p
			last_group[p] = g
		else: # starting node of a path
			first_group[g] = g
			last_group[g] = g
			paths.append(g)

	#sys.stderr.write("create path graph: %d paths\n"%(len(paths)))

	# create path graph
	edges = []
	progress=0
	for index,p in enumerate(paths):
		g = last_group[p]
		#if progress!=g*100/len(paths):
		#	progress=g*100/len(paths)
		#	sys.stderr.write("progress %d%%\n"%(progress))
		members = set(group_graph.group[g])
		#g_index = group_graph.groups_intime.index(g)
		for h in paths[index+1:]:
			if group_graph.group_time[h]<=group_graph.group_time[g]:
				continue
			h_inter = members & set(group_graph.group[h])
			if len(h_inter)>0:
				edges.append((p, h, len(h_inter)))
				members = members - h_inter
			if len(members)==0: break

	if not edges:
		sys.stderr.write("no edges\n")
		break

	# write gms file
	f = open(gms_fname, 'w')
	f.write("# generated by ipc-glpk.py\n")
	f.write("set V;\n")
	f.write("param w{V,V}>=0;\n")
	f.write("var x{V,V}>=0;\n")
	f.write("maximize total_w: sum{i in V, j in V} w[i,j] * x[i,j];\n")
	f.write("s.t. in_degree	{j in V}: sum{i in V} x[i,j] <= 1;\n")
	f.write("    out_degree	{i in V}: sum{j in V} x[i,j] <= 1;\n")
	f.write("data;\n")

	n = len(paths)
	m = len(edges)
	f.write("set V :=")
	for p in paths:
		f.write(" %d"%p)
	f.write(";\n")

	f.write("param w default 0, \n")
	for index,e in enumerate(edges):
		(g,h,w) = e
		f.write(" %d %d %d"%(g, h, w))
		if index % 5 == 4 or index==m-1: f.write("\n")
	f.write(";\n")

	f.write("end;\n")

	f.close()

	# run path-cover
	#rc = os.system("gams %s"%(gms_fname))
	if verbose:
		rc = os.system("glpsol -m %s -o %s 2>&1 | tee %s"%\
            (gms_fname, out_fname, log_fname))
	else:
		rc = os.system("glpsol -m %s -o %s > %s"%\
            (gms_fname, out_fname, log_fname))
	if rc!=0: raise Exception("System call return %d"%rc)

	# read output
	out = GlpxOutput(out_fname)
	pcpc_edges=out.edges
	sum_w=out.obj_value
	sys.stderr.write("%d\n"%sum_w)

	## debug
	#for u,v,w in sorted(pcpc_edges):
	#	print "%d,%d,%d"%(u,v,w)

	if pcpc_edges:
		for e in pcpc_edges:
			u,v = e
			if u not in last_group:
				print "u", u
				print "paths", paths
				print "last_group", last_group
			pc_edges.append((last_group[u], v))
	else:
		break

sys.stderr.write("clean up\n")
#sys.stderr.write("rm %s-ipc.glpk.%d.*\n"%(bname,pid))
os.system("rm " + prefix + "%s-ipc.glpk.%d.*" %(bname,pid))

#output
if limit==1:
	out_fname = prefix + "%s_pc.out" % bname
	gcolor_fname = prefix + "%s_pc.gcolor" % bname
	color2_fname = prefix + "%s_pc-c111.color2" % bname
	png_fname = prefix + "%s_pc-c111.png" % bname
else:
	out_fname = prefix + "%s_ipc.out" % bname
	gcolor_fname = prefix + "%s_ipc.gcolor" % bname
	color2_fname = prefix + "%s_ipc-c111.color2" % bname
	png_fname = prefix + "%s_ipc-c111.png" % bname
if not quiet:
	sys.stderr.write("(What's next?)\n")
	sys.stderr.write("gamsout2color.py %s >%s\n"\
		%(out_fname, gcolor_fname))
	sys.stderr.write("color_ind2 %s <%s >%s\n"\
		%(gtm_fname, gcolor_fname, color2_fname))
	#sys.stderr.write("color2dot %s %s -Tpng -o %s -ranksep 1\n"\
	#	%(gtm_fname, color2_fname, png_fname))
	#sys.stderr.write("color2dot %s %s -Tpng -wsize 100\n"\
	#	%(gtm_fname, color2_fname))
	sys.stderr.write("color3dot.py %s\n"%(color2_fname))

f = open(out_fname, 'w')
for e in sorted(pc_edges):
	u,v = e
	f.write("%d %d\n"%(u,v))
f.close()

